#lang ivy1.8

# A tuplespace node lives on the hash ring.  It can consume API actions from
# the client or from other nodes.

include order
include collections

include ts_types

global {
    instance node : iterable

    # All server messages are internal to the tuplespace implementation;
    # clients do not directly send these messages but simply "call into" the
    # tuplespace with exported actions.

    # TODO: It would be nice to be able to namespace these messages under
    # `server` to imply a certain information hiding, but I get errors about
    # dependency cycles...
    class tuple_msg_t = {
        # The operation to take when a node receives a particular message.
        action handle(self: node, ^msg:tuple_msg_t)

        # If the message is part of a larger protocol (such as a req/resp
        # pair), produce the message that should be returned to the sending
        # node.  Produces an empty return value if no such message need be
        # sent.  (The caller may still need to fill in certain fields.)
        # TODO: is this actually useful?  I'm not so sure anymore.
        #action next(self: node, ^msg:tuple_msg_t) returns (ret: option[tuple_msg_t])

        # Encodes the per-message policy to unicast, multicast, or broadcast a
        # given message type to its recipients.
        action send(self: node, ^msg: tuple_msg_t)
    }


    # A store is an internal operation mutates the tuplespace by adding a tuple
    # to all nodes in the tuplespace.  For details, see doc/operations.md .

    subclass tuple_store_req of tuple_msg_t = {
        field src : node
        field tpl : tuple

        action handle(self: node, ^msg:tuple_msg_t)
        action send(self: node, ^msg: tuple_msg_t)
    }

    subclass tuple_store_resp of tuple_msg_t = {
        field idem : bool # Was this an idempotent write (ie. did this tuple already exist?)
        field dst : node

        action handle(self: node, ^msg: tuple_msg_t)
        action send(self: node, ^msg: tuple_msg_t)
    }

    # A mark indicates that a remote server wishes to atomically remove a value
    # from the tuplestore.

    subclass tuple_mark_req of tuple_msg_t = {
        field src : node
        field tpl : tuple

        action handle(self: node, ^msg:tuple_msg_t)
        action send(self: node, ^msg: tuple_msg_t)
    }

    subclass tuple_mark_resp of tuple_msg_t = {
        field ok : bool # Did we mark this successfully?
        field dst : node

        action handle(self: node, ^msg:tuple_msg_t)
        action send(self: node, ^msg: tuple_msg_t)
    }


    # A delete is an internal operation structurally similar to a store - it mutates
    # the tuplespace by removing a marked tuple from the tuplespace.

    subclass tuple_delete_req of tuple_msg_t = {
        field src : node
        field tpl : tuple

        action handle(self: node, ^msg:tuple_msg_t)
        action send(self: node, ^msg: tuple_msg_t)
    }

    subclass tuple_delete_resp of tuple_msg_t = {
        field idem : bool # Was this an idempotent delete (ie. did this tuple not exist?)
        field dst : node

        action handle(self: node, ^msg:tuple_msg_t)
        action send(self: node, ^msg: tuple_msg_t)
    }

}

process server(self: node) = {

    export action insert(tpl: tuple)
    export action remove(tpl: tuple_template)
    export action read(tpl: tuple_template) returns (ret: option[tuple])

    implementation {
        implement insert {
            insert_commit(self, tpl);
        }

        implement remove {
        }

        implement read {

        }

        # Tuple writing

        implement tuple_store_req.handle {
            debug "tuple_store_req.handle" with self=self, msg=msg
            # TODO: 1) Perform the local write.
            # TODO: 2) Reply with a `tuple_store_resp`.
        }
        implement tuple_store_req.send {
            debug "tuple_store_req.send" with self=self, msg=msg
            # TODO: broadcast the store to all nodes.
        }

        implement tuple_store_resp.handle {
            debug "tuple_store_resp.handle" with self=self, msg=msg
            # TODO: Have we received a resp from all nodes?
            # If so, commit.
        }
        implement tuple_store_resp.send {
            debug "tuple_store_req.send" with self=self, msg=msg
            # TODO: Unicast the response back to the original sender
        }

        # Tuple marking

        implement tuple_mark_req.handle {
            debug "tuple_mark_req.handle" with self=self, msg=msg
            # TODO: 1) Perform the local write.
            # TODO: 2) Reply with a `tuple_mark_resp`.
        }
        implement tuple_mark_req.send {
            debug "tuple_mark_req.send" with self=self, msg=msg
            # TODO: broadcast the store to all nodes.
        }
        implement tuple_mark_resp.handle {
            debug "tuple_mark_resp.handle" with self=self, msg=msg
            # TODO: Have we received a resp from all nodes?
            # If so, commit.
        }
        implement tuple_mark_resp.send {
            debug "tuple_mark_req.send" with self=self, msg=msg
            # TODO: Unicast the response back to the original sender
        }
       
        # Tuple deletion

        implement tuple_delete_req.handle {
            debug "tuple_delete_req.handle" with self=self, msg=msg
            # TODO: 1) Perform the local write.
            # TODO: 2) Reply with a `tuple_delete_resp`.
        }
        implement tuple_delete_req.send {
            debug "tuple_delete_req.send" with self=self, msg=msg
            # TODO: broadcast the store to all nodes.
        }

        implement tuple_delete_resp.handle {
            debug "tuple_delete_resp.handle" with self=self, msg=msg
            # TODO: Have we received a resp from all nodes?
            # If so, commit.
        }
        implement tuple_delete_resp.send {
            debug "tuple_delete_req.send" with self=self, msg=msg
            # TODO: Unicast the response back to the original sender
        }
    }

    #TODO: global instead?
    common {
        specification {

            action insert_commit(self: node, t: tuple)
            action remove_commit(self: node, t: tuple)

            relation insert_inflight(N:node, T:tuple)
            relation insert_committed(N:node, T:tuple)
            relation remove_committed(N:node, T:tuple)

            after init {
                insert_committed(N,T) := false;
            }

            before insert(self: node, tpl: tuple) {
                insert_inflight(self, tpl) := true;
            }

            after read(self: node, tpl: tuple_template) returns (ret: option[tuple]) {
                # If we return anything, somebody must have committed it.
                if ~ret.is_empty {
                    require(insert_committed(N, ret.contents));
                }
            }

            before insert_commit {
                # TODO: is this just `after insert`?
                # TODO: we want to require that all the right nodes have stored
                # the tuple (???)

                require insert_inflight(self, t);
                insert_inflight(self, t) := false;
                insert_committed(self, t) := true;
            }

            before remove_commit {
                # We want to make sure that no nodes have the tuple anymore,
                # I think.

                require insert_committed(self, t);
                insert_committed(self, t) := false;
                remove_committed(self, t) := true;
            }
        }

    }
}

