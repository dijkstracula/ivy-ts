#lang ivy1.8

include multi_paxos
include utils

module manager_mod = {
    global {

        class man_msg_t = {
            action handle(self: manager_id, ^msg: man_msg_t)
        }

        subclass heartbeat_msg_t of man_msg_t = {
            field src: server_id    # For heartbeats, where did this originate?
            action handle(self: manager_id, ^msg: heartbeat_msg_t)
        }

        subclass view_msg_t of man_msg_t = {
            field src: server_id
            field view : nat               # For view updates, the view number
            field cur_servers : vector[server_id] # For view updates, current servers in view

            action handle(self: manager_id, ^msg: view_msg_t)
        }

        instance man_net : tcp_test.net(man_msg_t)
    }

    process manager(self: manager_id) = {
        var view : nat                      # The current view number
        var time : nat                      # The current time in seconds
        var heard(X:server_id) : nat        # Last time we head from server `X`
        var cur_servers : vector[server_id] # 
        var proposed : bool                 # Have we proposed a new view?

        export action is_down # When the failure detector detects a node has parted

        common {
            parameter fail_time : nat = 2
            instance opt_view_msg : option(view_msg_t)
        }

        instance sock : man_net.socket
        instance timer : timeout_sec
        instance paxos : multi_paxos(manager_id, opt_view_msg, opt_view_msg.empty) 

        implementation {

            # current_view 
            # 
            after init {
                view := 0;
                time := 0;
                proposed := false;

                for it, i in server_id.iter {
                    cur_servers := cur_servers.append(i);
                }
            }

            function is_up(S:server_id) = time <= heard(S) + fail_time

            action announce(view:nat, cur_servers:vector[server_id]) = {
                if ~proposed {
                    var msg : view_msg_t;
                    msg.view := view;
                    msg.cur_servers := cur_servers;
                    paxos.server.propose(manager.opt_view_msg.just(msg));
                    proposed := true;
                }
            }

            implement paxos.server.decide(inst: paxos.instance_t, op: opt_view_msg) {
                proposed := false;
                if ~op.is_empty {
                    view := view.next;

                    var msg : view_msg_t := op.contents;
                    msg.view := view;
                    broadcast(msg);
                }
            }

            action broadcast(msg:man_msg_t) = {
                for it, sv in server_id.iter {
                    sock.send(server(sv).man_sock.id, msg);
                    # TODO: this may all have to go in the same file since I'm not sure
                    # if Ivy will recognize what `server` is 
                }
            }

            implement sock.recv(src:tcp.endpoint,msg:man_msg_t) {
                msg.handle(self);
            }

            implement heartbeat_msg_t.handle {
                debug "heartbeat_msg_t.handle" with self=self, msg=msg;
            }

            implement view_msg_t.handle {
                debug "view_msg_t.handle" with self=self, msg=msg;

                if msg.view = view {
                    heard(msg.src) := time;
                }
            }
        }
    }

    # Topology changes should be very infrequent just so we spread the events out
    # through the test run.
    attribute manager.is_down.weight = "0.01"
}

